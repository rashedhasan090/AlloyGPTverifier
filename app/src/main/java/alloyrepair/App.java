/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package alloyrepair;

import edu.mit.csail.sdg.alloy4.A4Reporter;
import edu.mit.csail.sdg.alloy4.Err;
import edu.mit.csail.sdg.alloy4.ErrorWarning;
import edu.mit.csail.sdg.alloy4compiler.ast.*;
import edu.mit.csail.sdg.alloy4compiler.parser.CompUtil;
import edu.mit.csail.sdg.alloy4compiler.translator.*;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;

import java.io.FileWriter;
import java.io.IOException;

public class App {
    Module root = null;
    A4Solution ans = null;
    protected String result;
    protected ArrayList<String> resultsArray = new ArrayList<String>();
    static int solutionNo = 1;
    static int maxSol = 10000000;

    private Gson gson;
    private JsonObject jsonReport;
    private static List<String> warnings = new ArrayList<>();

    FileOutputStream oFile;
    static PrintStream pPRINT = null;

    HashMap<String, String> uniqueSkolems;
    HashMap<String, HashSet<String>> skolemsHashMAp;
    HashMap<String, Integer> src, dst, intents, perm;

    // [src-dst,Sol#]
    HashMap<String, HashSet<String>> distinctSrcDst;

    public App() {
        jsonReport = JsonHelper.createJsonObject("", "", "", "", "", "", "");
        gson = new GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create();
    }

    public void addCounterexample(String cntrCmd, String counterexample, String counterexampleMsg) {
        JsonHelper.addCounterexample(jsonReport, cntrCmd, counterexample, counterexampleMsg);
    }

    public void addInstance(String instanceCmd, String instances, String instanceMsg) {
        JsonHelper.addInstance(jsonReport, instanceCmd, instances, instanceMsg);
    }

    public void updateError(String errorMessage) {
        jsonReport.addProperty("error", errorMessage);
    }

    public JsonObject getMyJson() {
        return jsonReport;
    }

    public void writeJsonToFile(String fileName) {
        try (FileWriter writer = new FileWriter(fileName)) {
            gson.toJson(jsonReport, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void updateErrorWithStackTrace(Exception err, String model) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        err.printStackTrace(pw);
        String stackTrace = sw.toString(); // Stack trace as a string

        //Extract Alloy spec file name
        Path path = Paths.get(model);
        Path fileName = path.getFileName();

        StringBuilder errorSB = new StringBuilder();
        if (stackTrace.contains("Type error")){
            int i = 0;
            errorSB.append("Compiling the Alloy model " + fileName + " generates a type error at ");
            for (String comp: stackTrace.split("\n")){
                if (i == 0 && comp.contains(" at ")){
                    String[] warningComps = comp.split(" at ");

                    errorSB.append(warningComps[1] + "\n");
                }else if(!comp.contains("\tat")){
                    errorSB.append(comp + "\n");
                }
                i++;
            }
        }else if(stackTrace.contains("Syntax error")){
            int i = 0;
            errorSB.append("Compiling the Alloy model " + fileName + " generates a syntax error at ");
            for (String comp: stackTrace.split("\n")){
                if (i == 0 && comp.contains(" at ")){
                    String[] warningComps = comp.split(" at ");

                    errorSB.append(warningComps[1] + " (The true origin of this syntax error could be before or after this line)" + "\n");
                }else if(!comp.contains("\tat")){
                    errorSB.append(comp + "\n");
                }
                i++;
            }


        }else{
            errorSB.append(stackTrace);
        }
        jsonReport.addProperty("error", errorSB.toString().replaceAll("this/",""));
    }

    /**
     * This object performs expression evaluation.
     *
     * @param args AlloyFile Query
     */

    public static void main(String args[]) throws FileNotFoundException {
        String als_path = args[0];
        String reportFile = als_path.substring(0, als_path.length() - 4);

        App e = new App();

        try {
            e.callAlloyEngine(als_path);
            e.writeJsonToFile(reportFile + "_alloyAnalyzerReport.json");
        } catch (Exception err) {
            e.updateErrorWithStackTrace(err,als_path);
            e.writeJsonToFile(reportFile + "_alloyAnalyzerReport.json");
        }
    }

    public static boolean isNumeric(String string) {
        int intValue;

//        System.out.println(String.format("Parsing string: \"%s\"", string));

        if(string == null || string.equals("")) {
//            System.out.println("String cannot be parsed, it is null or empty.");
            return false;
        }

        try {
            intValue = Integer.parseInt(string);
            return true;
        } catch (NumberFormatException e) {
//            System.out.println("Input String cannot be parsed to Integer.");
        }
        return false;
    }

    private static String commandSimplifier(String command){
        String newCommand = command;
        if (!command.equals(null) && command.contains("expect")){
            String[] commandComps = command.split("expect");
            newCommand = commandComps[0].trim();
        }
        return newCommand;
    }

    public void callAlloyEngine(String model) throws Err, FileNotFoundException {
        uniqueSkolems = new HashMap<String, String>();
        skolemsHashMAp = new HashMap<String, HashSet<String>>();

        src = new HashMap<String, Integer>();
        dst = new HashMap<String, Integer>();
        intents = new HashMap<String, Integer>();
        perm = new HashMap<String, Integer>();

        distinctSrcDst = new HashMap<String, HashSet<String>>();

        //Extract Alloy spec file name
        Path path = Paths.get(model);
        Path fileName = path.getFileName();

        //Compilation Error Message Formatting
        A4Reporter rep = new A4Reporter() {
            @Override
            public void warning(ErrorWarning msg) {

                StringBuilder warningSB = new StringBuilder();
                String warningText = msg.toString().trim();
                int i = 0;
                warningSB.append("Compiling the Alloy model " + fileName + " generates a compilation error at ");
                for (String comp: warningText.split("\n")){
                    if (i == 0 && comp.contains(" in ")){
                        String[] warningComps = comp.split(" in ");

                        warningSB.append(warningComps[0] + "\n");
                    }else{
                        warningSB.append(comp + "\n");
                    }
                    i++;
                }

//                if (warningText.contains(model)) {
//                    // Replace the model path with "the specification"
//                    warningText = warningText.replace(model, "the Alloy model");
//                }
                warnings.add(warningSB.toString().replaceAll("this/","")+"\n");
            }

        };



        root = CompUtil.parseEverything_fromFile(rep, null, model);

        String warningsConcatenated = String.join(" ", warnings);
        updateError(warningsConcatenated);

        A4Options options = new A4Options();
        options.solver = A4Options.SatSolver.SAT4J; // .KK;//.MiniSatJNI; //.MiniSatProverJNI;//.SAT4J;
        options.symmetry = 20;
        options.skolemDepth = 1;

        // long now, start = System.currentTimeMillis();
        SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        // Date startTime = new Date(start);

        for (Command command : root.getAllCommands()) {
            //Simplify command
            String newCommand = commandSimplifier(command.toString());

            if (command.toString().contains("Check")) {
                String cntr_cmd, counterexample, counterexample_msg;
                cntr_cmd = command.toString();

                try {
                    ans = TranslateAlloyToKodkod.execute_command(rep, root.getAllReachableSigs(), command, options);
                } catch (Err err) {
                    err.printStackTrace();
                }
                for (ExprVar a : ans.getAllAtoms()) {
                    root.addGlobal(a.label, a);
                }
                for (ExprVar a : ans.getAllSkolems()) {
                    root.addGlobal(a.label, a);
                }



                if (ans.satisfiable()) {
                    counterexample = "Yes";
                    StringBuilder sb = new StringBuilder();
                    A4TupleSet univTupleSet = ans.eval(ans.getAllReachableSigs().get(0));
                    HashMap<String, String> atomsNameMap = new HashMap<>();
                    for (A4Tuple a4Tuple: univTupleSet){

                        if (!isNumeric(a4Tuple.toString())){

                            String[] comps= a4Tuple.toString().split("\\$");
                            StringBuilder newTupleName = new StringBuilder();

                            for (int i = 0; i < comps[0].length(); i++) {
                                Character c = comps[0].charAt(i);
                                if (Character.isUpperCase(c)){
                                    newTupleName.append(c);
                                }
                            }
                            newTupleName.append(comps[1]);
                            atomsNameMap.put(a4Tuple.toString(), newTupleName.toString());

                        }

                    }



                    for (Sig sig : ans.getAllReachableSigs()) {
                        if (sig.builtin)
                            continue;

                        StringBuilder newSigBuilder = new StringBuilder();
                        newSigBuilder.append("{");
                        if (ans.eval(sig).size() > 0 ){
                            for (A4Tuple tuple : ans.eval(sig)){
                                if (atomsNameMap.containsKey(tuple.toString())){
                                    newSigBuilder.append(atomsNameMap.get(tuple.toString())).append(",");
                                }
                            }
                            newSigBuilder.deleteCharAt(newSigBuilder.length() - 1);
                        }


                        newSigBuilder.append("}");

                        String newSigLabel = sig.toString().replaceAll("this/","");
                        sb.append(newSigLabel).append("=").append(newSigBuilder).append("\n");
//                        sb.append(sig).append("=").append(ans.eval(sig)).append("\n");
                        // Iterate over the fields of each signature
                        for (Sig.Field field : sig.getFields()) {
                            // Print the tuple set for each field
                            StringBuilder newFieldBuilder = new StringBuilder();

                            newFieldBuilder.append("{");
                            if (ans.eval(field).size() > 0) {
                                for (A4Tuple tuple : ans.eval(field)) {

                                    String newTuple = "";
                                    for (String ele : tuple.toString().split("->")) {

                                        if (atomsNameMap.containsKey(ele)) {
                                            newTuple += atomsNameMap.get(ele);
                                        } else {
                                            newTuple += ele;
                                        }

                                        newTuple += "->";
                                    }
                                    newTuple = newTuple.substring(0, newTuple.length() - 2);
                                    newFieldBuilder.append(newTuple).append(",");
                                }

                                newFieldBuilder.deleteCharAt(newFieldBuilder.length() - 1);
                            }
                            newFieldBuilder.append("}");

                            sb.append(newSigLabel).append(".").append(field.label).append("=").append(newFieldBuilder)
                                    .append("\n");

//                            sb.append(sig).append(".").append(field.label).append("=").append(ans.eval(field))
//                                    .append("\n");
                        }
                    }
//                    System.out.println(sb);
                    counterexample_msg = "Executing command ["+ newCommand + "] of the Alloy model " + fileName.toString() +", Alloy Analyzer found an counterexample, indicating 'assert " + command.label + "' is violated by this counterexample:\n" + sb;
//                    counterexample_msg = "Counterexample found which means that " + command + " assertion is invalid\n" + sb;
                } else {
                    counterexample = "no";
                    counterexample_msg = "Executing command ["+ newCommand + "] of the Alloy model " + fileName.toString() +", Alloy Analyzer found no counterexample, indicating that assert '"
                            + command.label + "' is valid";
//                    counterexample_msg = "Counterexample not found which means that " + command + " is valid";
                }
                addCounterexample(cntr_cmd, counterexample, counterexample_msg);
            } else if (command.toString().contains("Run")) {
                String instance_cmd, instance, instance_msg;
                instance_cmd = command.toString();
                try {
                    ans = TranslateAlloyToKodkod.execute_command(rep, root.getAllReachableSigs(), command, options);
                } catch (Err err) {
                    err.printStackTrace();
                }
                for (ExprVar a : ans.getAllAtoms()) {
                    root.addGlobal(a.label, a);
                }
                for (ExprVar a : ans.getAllSkolems()) {
                    root.addGlobal(a.label, a);
                }

                if (ans.satisfiable()) {
                    instance = "Yes";
                    instance_msg = "Executing command ["+ newCommand + "] of the Alloy model " + fileName.toString() +", Alloy Analyzer generates a valid instance, indicating that the model is consistent and 'pred "
                            +command.label + "' is satisfied";
//                    instance_msg = "Instance found which means that the specification is consistent";
                } else {
                    instance = "No";
                    instance_msg = "Executing command ["+ newCommand + "] of the Alloy model " + fileName.toString() +", Alloy Analyzer does not generate a valid instance, indicating that the model is inconsistent and 'pred "
                            +command.label + "' or other constraints in the 'fact' is violated";
                }
                addInstance(instance_cmd, instance, instance_msg);
            }
        }
    }
}