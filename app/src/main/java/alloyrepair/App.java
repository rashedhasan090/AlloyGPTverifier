/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package alloyrepair;

import edu.mit.csail.sdg.alloy4.A4Reporter;
import edu.mit.csail.sdg.alloy4.Err;
import edu.mit.csail.sdg.alloy4.ErrorWarning;
import edu.mit.csail.sdg.alloy4compiler.ast.*;
import edu.mit.csail.sdg.alloy4compiler.parser.CompUtil;
import edu.mit.csail.sdg.alloy4compiler.translator.A4Options;
import edu.mit.csail.sdg.alloy4compiler.translator.A4Solution;
import edu.mit.csail.sdg.alloy4compiler.translator.TranslateAlloyToKodkod;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.text.SimpleDateFormat;
import java.util.*;

import java.nio.file.Path;
import java.nio.file.Paths;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

public class App {
    Module root = null;
    A4Solution ans = null;
    protected String result;
    protected ArrayList<String> resultsArray = new ArrayList<String>();
    static int solutionNo = 1;
    static int maxSol = 10000000;

    JsonObject jsonObject = new JsonObject();
    private static List<String> warnings = new ArrayList<>();

    FileOutputStream oFile;
    static PrintStream pPRINT = null;

    HashMap<String, String> uniqueSkolems;
    HashMap<String, HashSet<String>> skolemsHashMAp;
    HashMap<String, Integer> src, dst, intents, perm;

    // [src-dst,Sol#]
    HashMap<String, HashSet<String>> distinctSrcDst;

    public App() {
    }

    /**
     * This object performs expression evaluation.
     *
     * @param args AlloyFile Query
     */

    public static void main(String args[]) throws FileNotFoundException {
        String als_path = args[0];
        App e = new App();
        e.jsonObject.addProperty("cntr_cmd", "");
        e.jsonObject.addProperty("counterexample", "");
        e.jsonObject.addProperty("counterexample_msg", "");
        e.jsonObject.addProperty("instance_cmd", "");
        e.jsonObject.addProperty("instance", "");
        e.jsonObject.addProperty("instance_msg", "");
        e.jsonObject.addProperty("error", "");
        try {
            e.callAlloyEngine(als_path);
        } catch (Exception err) {
            err.printStackTrace();
            e.jsonObject.addProperty("error", err.toString());
        }
    }

    public static String instanceParser(String sol, Map<String, Sig> sigs) {
        String[] lines = sol.split("\n");
        for (String line : lines) {
            String firstPart = line.split("=")[0];
            if (firstPart.contains("<:")) {
                System.out.println(line);

            } else {
                boolean flag = false;
                for (Sig sig : sigs.values()) {
                    if (sig.toString().equals(firstPart)) {
                        flag = true;
                        break;
                    }
                }
                if (flag) {
                    System.out.println(line);
                }
            }
        }
        return sol;
    }

    public void callAlloyEngine(String model) throws Err, FileNotFoundException {
        Path path = Paths.get(model);

        // Get the parent path (directory path without the file name)
        Path directoryPath = path.getParent();

        // Convert the directory path to String
        String directoryPathStr = directoryPath.toString();

        uniqueSkolems = new HashMap<String, String>();
        skolemsHashMAp = new HashMap<String, HashSet<String>>();

        src = new HashMap<String, Integer>();
        dst = new HashMap<String, Integer>();
        intents = new HashMap<String, Integer>();
        perm = new HashMap<String, Integer>();

        distinctSrcDst = new HashMap<String, HashSet<String>>();

        A4Reporter rep = new A4Reporter() {
            @Override
            public void warning(ErrorWarning msg) {
                String warningText = "Warning " + msg.toString().trim();
                if (warningText.contains(model)) {
                    // Replace the model path with "the specification"
                    warningText = warningText.replace(model, "the specification");
                }
                warnings.add(warningText);
            }
        };
        root = CompUtil.parseEverything_fromFile(rep, null, model);

        String warningsConcatenated = String.join(" ", warnings);
        jsonObject.addProperty("error", warningsConcatenated);

        A4Options options = new A4Options();
        options.solver = A4Options.SatSolver.SAT4J; // .KK;//.MiniSatJNI; //.MiniSatProverJNI;//.SAT4J;
        options.symmetry = 20;
        options.skolemDepth = 1;

        // long now, start = System.currentTimeMillis();
        SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        // Date startTime = new Date(start);

        for (Command command : root.getAllCommands()) {
            if (command.toString().contains("Check")) {
                jsonObject.addProperty("cntr_cmd", command.toString());

                try {
                    ans = TranslateAlloyToKodkod.execute_command(rep, root.getAllReachableSigs(), command, options);
                } catch (Err err) {
                    err.printStackTrace();
                }
                for (ExprVar a : ans.getAllAtoms()) {
                    root.addGlobal(a.label, a);
                }
                for (ExprVar a : ans.getAllSkolems()) {
                    root.addGlobal(a.label, a);
                }

                if (ans.satisfiable()) {
                    jsonObject.addProperty("counterexample", "Yes");

                    // String parsedInstance = instanceParser(ans.toString(), root.getSigs());
                    StringBuilder sb = new StringBuilder();
                    for (Sig sig : ans.getAllReachableSigs()) {
                        if (sig.builtin)
                            continue;
                        sb.append(sig).append("=").append(ans.eval(sig)).append("\n");

                        // Iterate over the fields of each signature
                        for (Sig.Field field : sig.getFields()) {
                            // Print the tuple set for each field
                            sb.append(sig).append(".").append(field.label).append("=").append(ans.eval(field))
                                    .append("\n");
                        }
                    }
                    jsonObject.addProperty("counterexample_msg",
                            "Counterexample found which means that " + command + " assertion is invalid\n" + sb);
                } else {
                    jsonObject.addProperty("counterexample", "no");
                    jsonObject.addProperty("counterexample_msg",
                            "Counterexample not found which means that " + command + " is valid");
                }

            } else if (command.toString().contains("Run")) {
                jsonObject.addProperty("instance_cmd", command.toString());
                try {
                    ans = TranslateAlloyToKodkod.execute_command(rep, root.getAllReachableSigs(), command, options);
                } catch (Err err) {
                    err.printStackTrace();
                }
                for (ExprVar a : ans.getAllAtoms()) {
                    root.addGlobal(a.label, a);
                }
                for (ExprVar a : ans.getAllSkolems()) {
                    root.addGlobal(a.label, a);
                }

                if (ans.satisfiable()) {
                    jsonObject.addProperty("instance", "Yes");
                    jsonObject.addProperty("instance_msg",
                            "Instance found which means that the specification is consistent");
                } else {
                    jsonObject.addProperty("instance", "No");
                    jsonObject.addProperty("instance_msg",
                            "Instance not found which means that the specification is not consistent.");
                }
            }
        }
        Gson gson = new GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create();

        // Write the JSON object to a file
        try (Writer writer = new FileWriter(directoryPathStr + "/" + "alloyAnalyzerReport.json")) {
            gson.toJson(jsonObject, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    protected void solve(String AlloyFile) {
        // Alloy4 sends diagnostic messages and progress reports to the A4Reporter.
        // By default, the A4Reporter ignores all these events (but you can extend the
        // A4Reporter to display the event for the user)
        A4Reporter rep = new A4Reporter() {
            // For example, here we choose to display each "warning" by printing it to
            // System.out
            @Override
            public void warning(ErrorWarning msg) {
                System.out.print("Relevance Warning:\n" + (msg.toString().trim()) + "\n\n");
                System.out.flush();
            }
        };

        try {
            root = CompUtil.parseEverything_fromFile(rep, null, AlloyFile);
        } catch (Err err) {

            err.printStackTrace();
        }
        A4Options options = new A4Options();
        options.solver = A4Options.SatSolver.SAT4J;// .KK;//.MiniSatJNI; //.MiniSatProverJNI;//.SAT4J;

        options.symmetry = 20;
        options.skolemDepth = 1;

        for (Command command : root.getAllCommands()) {
            // Execute the command
            System.out.println("============ Command " + command + ": ============");
            try {
                ans = TranslateAlloyToKodkod.execute_command(rep, root.getAllReachableSigs(), command, options);
            } catch (Err err) {
                err.printStackTrace();
            }
            for (ExprVar a : ans.getAllAtoms()) {
                root.addGlobal(a.label, a);
            }
            for (ExprVar a : ans.getAllSkolems()) {
                root.addGlobal(a.label, a);
            }
        }
    }
}